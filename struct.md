C ল্যাংগুয়েজে একাধিক ভেরিয়েবল নিয়ে গ্রুপ ভেরিয়েবল ডিক্লেয়ার করা যায়। এই গুপটিকে বলা হয় স্ট্রাকচার। আমরা যদি কোন এক ব্যাক্তির নাম, বয়স এবং তার বেতন নিয়ে কাজ করতে চাই তাহলে সেগুলো একসাথে রাখা সুবিধাজনক।

সেজন্য আমরা এভাবে স্ট্রাকচার তৈরি করিঃ

```
struct [struct_name]
{
  [structure fields]
};
```

যেমনঃ

```c
struct Person
{
    char name[20];
    int age;
    int salary;
};
```

এখানে স্ট্রাকচারে তিনটি ফিল্ড রয়েছে- name, age এবং salary । এই ফিল্ড তিনটিকে কোন আলাদা ভেরিয়েবল ধরার দরকার নেই। এগুলো সবসময় একসাথে থাকবে। তবে আলাদে ভাবে এদের মান দেখা বা পরিবর্তন করা যাবে।

এখন এই স্ট্রাকচারটিকে আমরা সাধারন একটা প্রাথমিক (primitive type) টাইপের ভেরিয়েবলের মত ব্যবহার করতে পারব।

যেমন এভাবে ভেরিয়েবল ডিক্লেয়ার করা হয়ঃ

```
Person p1;
```

[বিঃদ্রঃ আমরা বেশিরভাগ সময় C++ কম্পাইলার ব্যবহার করি। সেকারনে একেবারে শুদ্ধ C ল্যাংগুয়েজ ব্যবহার করার চেষ্টা করছি না এই লেকচারে।]

## Initializing a Structure
ভেরিয়েবল ডিক্লেয়ার করার সময়ই অন্য টাইপের ভেরিয়েবলের যেমন প্রাথমিক মান ঠিক করে দেয়া যায় সেরকম স্ট্রাকচারের ক্ষেত্রেও করা যায়ঃ

```
Person p1 = {”Kalam”, 38, 60000};
```

এক্ষেত্রে স্টাকচারের ফিল্ডগুলোর ক্রম ঠিক রাখতে হবে।

ক্রম উলটাপাল্টা করতে চাইলে ফিল্ডগুলোর নামসহ এভাবে লেখা যায়ঃ

```c
Person p1 = { .age = 38, .name = "Kalam", .salary= 60000};
```

ফিল্ডের নামের আগে ডট (.) দিতে হবে। এক্ষেত্রে ইচ্ছা করলে এক বা একাধিক ফিল্ডের মান না দিলেও অসুবিধা নেই।

স্ট্রাকচারের ফিল্ডগুলো নিয়ে আলাদা ভাবে কাজ করতে চাইলে ডট (.) ব্যবহার করে করা যায়ঃ

```c
int current_age;
Person p1;

p1.name = "Kalam";
p1.age = 38;
p1.salary = 60000;

current_age = p1.age
Assignment
Person p1 = {"Kalam", 38, 60000};

Person p2;
p2 = p1; /* copies the member values from p1 into p2. */
```

এখানে মনে রাখতে হবে এভাবে একটা ভেরিয়েবল থেকে আরেকটাতে মান কপি করলে দুইটা আলাদা ভেরিয়েবল হিসাবে কাজ করবে। একটাতে মান পরিবর্তন করলে আরেকটাতে কোন পরিবর্তন হবে না।

যেমন p2.age=56; লিখলে p1.age এর মানের কোন পরিবর্তন হবে না।

Functions and Structures
ফাংশনের প‌্যারামিটার বা রিটার্ন ভ্যালু হিসাবে অন্য যেকোন টাইপের ভেরিয়েবলের মতই স্ট্রাকচার ব্যবহার করা যায়।

নীচের প্রোগ্রামটি লক্ষ করুণঃ

```
#include "stdio.h"

void print_person(Person p)
{
    printf("Name: %sn", p.name);
    printf("Age: %dn", p.age);
    printf("Salary: %dn", p.salary);
}

void main()
{
    Person p1 = {"Kalam", 38, 60000};
    print_person(p1);
}
```
এখানে ভ্যালু হিসাবে পাঠানো হচ্ছে স্ট্রাকচার। ফাংশনের মধ্যে কোন ফিল্ডের মান পরিবর্তন করলে সেটা ফাংশনের বাইরে কোন প্রভাব ফেলবে না বা মান পরিবর্তন হবে না।

রেফারেন্স হিসাবেও স্ট্রাকচার ভেরিয়েবল ব্যবহার করা যায় এভাবে (অন্য টাইপের ভেরিয়েবলের মতই ভরিয়েবলের নামের পূর্বে & ব্যবহার করে)

```
#include "stdio.h"

void test_person(Person &p)
{
    if(p.age == 0)
    {
        p.age=18;
    }
}

void main()
{
    Person p1 = {"Kalam", 0, 60000};
    test_person(p1);

    printf("Age: %d", p1.age);
}
```

এখনে Age: 18 এভাবে আউটপুট পাব।

## Arrays of Structure
অন্য টাইপের মতই স্ট্রাকচারের Array তৈরি ও ব্যবহার করা যায়ঃ

ডিক্লেয়ার করার জন্য এভাবে লিখতে হবেঃ
```c
Person pn[10];
```
এখন অন্য টাইপের ভেরিয়েবলের মতই ইনডেক্স ব্যবহার করা যাবে এভাবেঃ
```c
pn[0].age = 30;

pn[9].salary=50000;
Structure within a Structure (nested structure)
```
আমরা যদি্‌ ব্যক্তির ঠিকানাও রাখতে চাই একসাথে তাহলে আমরা nested structure ব্যবহার করে সেটা করতে পারিঃ

```c
struct Person
{
    char name[20];
    int age;
    int salary;
    struct address
    {
        int house_no;
        char street[30];
        char post[30];
        char district[30];
    };
};
```

এক্ষেত্রে যেভাবে ব্যবহার করতে হবেঃ

```
Person p1;

p1.age = 34;
p1.address.house_no = 2543;
```
